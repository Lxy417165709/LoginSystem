
## 加盐哈希（对明文密码的加密）
1. 操作流程：将明文密码与一个随机产生的盐值进行拼接，将得到的字符串进行哈希，可得最终的密文密码。  （哈希算法采用 SHA1）
2. 存储过程：将密文密码 和 盐值 一起存到数据库中。
3. 验证过程：将需要验证的明文密码与验证拼接，将得到的字符串进行哈希，如果最终得到的密文密码与数据库中存储的密文密码一样，则密码验证通过，否则则不通过。
4. 盐值的产生：在小写字母、数字字符中随机选取5个，拼接为“盐值”。


## 加密解密
1. 采用AES加密（AES需要一个16位的密钥），而且为了符合AES加密的要求(要求字符串是16字节的倍数)
   程序在每个需要加密的字符串后添加了一段信息(叫padding)，该字符串和信息拼接在一起
   后形成的字符串的长度是16字节的倍数。对这个形成的字符串进行AES加密,得到其密文。
2. 当一个16字节倍数的密文字符串需要解密时(这个字符串必须带有信息)，首先先对他进行解密，得到明文字符串，之后再通过去除padding，就能得到原始的字符串了。
3. padding的做法就是：先得出字符串还差多少字节才能到达16的倍数。（如果刚好是16的倍数，那差的字节是16字节）。
	假如这个数字是n，则将其重复n次，形成长度为n的字符串，之后再拼接到原始字符串的末尾，此时，padding就完成了。
4. unPadding过程：取解密后的明文字符串的最后一个字节的ASCILL码值，记这个为n，
	之后截掉解密后明文字符串的末n个字节，就得到了原始的明文字符串了。
	
## JWT token生成
1. 每个用户都有一个用户ID，我将用户ID封装到JWT结构中(这里可以说说JWT的结构是怎样的)，之后形成token字符串。
2. 由于形成的token字符串是使用Base64编码的，还属于明文的范畴，所以我再使用加密算法进行了加密。
3. 校验的时候，先将密文解密，获得明文token，之后判断是否过期，过期了就通知用户，没有过期就进行下一步操作。
	
## 配置
1. 通过外部读取ini文件，配置 数据库连接等相关信息。


## 校验
1. 给需要校验的结构体的字段添加标签，比如登录信息结构体，它需要邮箱、密码，那么我就在邮箱字段添加一个email标签，而密码字段则添加一个password标签。
2. 将需要校验的结构体传入一个函数，这个函数会读取字段标签，然后进行校验，并返回相应的信息。

缺点：校验函数太大了，重复代码很多，不方便维护。

## postgre操作的设计
1. 每一张数据表，我定义了一个结构体，比如表中有 email,password字段，那么结构体中也有这些字段。
2. 在执行数据增删改查的时候，我会通过反射生成相应的sql语句，之后再执行。
3. 如更新用户信息的时候，比如要修改它的userName,那我会新建一个用户信息结构体，将其userName字段置为需要修改后的值，之后形成sql语句，再交由数据库执行。
增加用户信息的时候也类似。

缺点：采用这种方式虽然可以很方便的更新、添加用户信息，但是删除、select操作将不是很优美，比如删除、select需要设置where条件，所以我又需要传入参数，告知where条件是什么。 这种混杂的方式，使代码很不优美，而且也不灵活...


中间遇到的问题：在生成sql语句时，最开始会导致sql注入的问题，之后采用先生成stmt的方式，再为其传入参数，从而避免sql注入问题。

改进：我要废弃这种方式，采用原始方式，自己编写sql语句，这样灵活性好。

## 测试
有采用go提供的框架进行测试，但是测试不太全。而且有时候更改代码后，又要重新编写测试的代码..

## 遇到的困难

### 业务逻辑与校验
1. 业务逻辑与校验的分离，原来的代码中，业务逻辑和校验是混杂的，违反了单一职责原则，导致代码可读性很差，而且会进行重复的校验代码。
2. 之后将业务逻辑和校验分离，先对数据进行校验，校验无误后再执行。

### 配置导致代码耦合度增大
1. 在连接postgre数据库的时候，我直接引用初始化完毕的配置，而不是用参数的形式传入给它。
2. 这导致连接postgre数据库的这个函数很依赖配置。
3. 所以我将配置，比如端口、IP都作为它的参数传入给它，这样就可以解耦了。

## 经验
1. 不要过早封装接口： 在数据库方面，我给postgresql定义了几个方法，如insert、delete、update、select.. 但这些其实没必要，因为我只是用到了postgresql，我没用其他的数据库。过早的封装接口，导致我代码必须顺应着这个接口，变成了为了实现接口而实现接口。
2. 要提前进行设计，做出一些规范
如果没有做出规范，那么代码的变量命名会出现不一致的问题。比如 有的地方用户名被命名为userName，但是有个地方被命名为email。
3. 包名不要定义过长
包名定义过长，引用的时候很不舒服，降低了代码的可读性。
4. 日志方面
在每个出现错误的地方，都应输出日志。  因为我一般是在最顶层输出日志的，但这种方法会导致每次出现错误，我又要深入下层去排除，浪费的时间增多了。  比如数据的更新操作，直接调用这个函数就能更新数据库以及redis缓存中的数据，所以这涉及两步，一步是更新主数据库的数据，一步是删除redis数据库的数据。
如果没有主数据库更新发生错误、以及redis更新发生错误时的日志输出，当数据更新操作发生错误时，我就要向下排查了，而如果有，我通过日志就能知道错误的来源了。
5. 系统错误和用户错误要分开
比如校验邮箱格式的时候，如果是正则表达式错误，那么不应该让用户知道，因为这是系统的错误，对于这个错误，可以直接panic，在开发时就改正。
6. 意识到编码是一个迭代的过程，不可能一蹴而就，中途肯定会有错误。