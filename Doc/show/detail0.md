## 项目介绍
1. 背景: 这是我的一个练手项目，用于实践所学知识。
2. 功能与整体设计: 这个项目的主要功能有 登录、邮箱注册、以及修改用户个人信息。整体设计采用分层的设计思想，一共分为 5 层，从底层到上层分别是: 数据库层、过渡层、校验层、控制层、中间件层。最满意的是中间件层，这一层能很方便的为请求处理函数添加中间件，例如计算该请求处理时长的中间件、计算该路由被访问次数的中间件。信息安全方面我也比较满意，因为密码存储我采用了加盐哈希存储，而jwt在传输时，也有进行加密。也解决过该项目中sql注入的问题。
3. 角色以及工作内容: 整个项目都是由我一个人搭建，包括前端后端数据库。而且整个项目的后端没用框架，所以架构还得自己设计。这是最困难的。最开始做这个项目的时候，没有进行分层，导致每个函数代码都很多，可读性极差，功能混杂。之后受到TCP/IP协议的启发，开始采用分层的架构。这使得代码可读性提高了许多，但由于没有独立出校验层，导致路由处理函数遍布很多判断，而这些判断有许多是重复的，从而导致代码冗余。现在的这个版本已经独立出了校验层，所有表单的数据校验都放在了这一层。
4. 收获:
	1. 编写代码前需要进行初步设计，可以采用分层架构，并为赋予每一层相应的职责。
	2. 不要过早定义接口，不要生搬硬套设计模式。
	3. 编写代码不应只以功能实现为唯一目的，而更重要的是测试、以及提高代码可读性。
5. 可以提高的空间:
	1. 功能不够完善，应该给用户添加个忘记密码的功能。
	2. 代码不够优美，有许多地方的命名没有名副其实，或容易产生混淆。
	3. 测试不够自动化，编写过程中有进行简单的测试，但还是存在修改了源代码，导致测试代码也要进行修改的问题。



## 接口设计
1. 主要有以下几个接口
	1. 实现登录的接口有1个
		/server/login 请求方法是post,传入的信息是邮箱和登录密码。
	2. 实现注册的接口有2个
		/server/register 请求方法是Post,传入的信息是注册邮箱、注册密码、验证码
		/server/registerVrc/send 请求方法是Post,传入的信息是验证码发往的邮箱
	4. 还有2个更新信息的接口，
		/server/updatePhoto 这个用户更新用户头像，传入用户头像数据
		/server/updateUserPersonalInformation 这个用户更新用户的个人信息,传入用户更新后的个人信息。
	5. 还有3个获取信息的接口 
		/server/getPhoto，用户获取用户头像
		/server/getUai 用于获取用户账户信息
		/server/getUpi 用户获取用户个人信息
	6. 还有1个测试接口 
		/server/test 这个接口用户测试服务器是否能访问
	
	这些接口都可以用Post方法进行访问。
	

## 整体架构
1. 数据库层: 职责是进行存储，以及访问存储数据，postgresql、redis、图片上传、验证码发送都放在这了。 这里还将postgresql、redis集成为了一个叫dataCenter的对象，这个对象在访问数据时，会优先查看redis的缓存数据，没有就会再去查postgresql数据库。
2. 过渡层: 将postgresql、redis、图片上传器、邮件发送器结合为一个称为FPI的结构，这个结构对外提供数据访问的接口。
3. 校验层: 负责数据的校验。
4. 控制层: 负责获取请求中的数据、获得token。
5. 中间件层: 为路由处理函数加入中间件，比如计算处理该请求花费了多少时间、计算路由被访问了多少次。


-. 配置层: 控制程序的上下文环境。

## 设计
### 中间件层怎么设计？
1. 我创建了一个 Handler 结构，它有两个成员，一个类型是路处理函数的类型 ，一个是切片类型，这个切片里面可以存储中间件的函数，比如计算耗时的函数、统计次数的函数。 
2. Handler结构还有一个Format方法，这个方法能将路由处理函数和中间件函数结合，返回一个新的处理函数，该处理函数里面集成了中间件函数。
3. 当请求到达的时候，main函数会将路由引向这个集成了中间件函数的处理函数，这就实现了在处理的同时，实现计算费时。

### 控制层怎么设计？
1. 控制层里面有很多路由处理函数，比如Login函数，这个可以处理登录请求，还有Register函数，这个可以处理注册请求。
2. 以Login函数为例，它的流程是这样的: 首先先获得请求的表单，之后再进行数据校验，当数据校验没有问题时，就将数据交予下层。
当下层返回成功后，就给用户返回登录成功，在这过程中出现任何问题，就给用户返回错误。
3. 而对于获取个人信息的请求，它的处理函数还包括获取token，判断token是否合法。


### 怎么判断token合法？
1. 我的token采用的是jwt,jwt由3部分构成，一部分是头部，这里面包括了哈希的算法，第二部分是载荷，这里面包括了实际的数据、过期时间 (我存储的是用户id)，而第三部分是签名，这个签名就是jwt json对象通过密钥哈希后的结果。
2. 由于jwt是明文的，所以在获得jwt字符串后，我对该jwt字符串还进行了加密。
3. 那么判断token合法就有以下步骤了。
		1. 先将jwt密文字符串解密，获得jwt明文字符串。
		2. 通过密钥，解析出原始的jwt结构。 (这个过程以及包括了判断jwt签名是否合法)
		3. 之后判断jwt是否过期，如果过期就返回过期错误。

### 校验层怎么设计？
1. 以登录数据的校验为例，我将登录数据封装到了一个叫LoginDTO的结构，这个结构有2个字段，一个是Email、一个是Password，我为这2个字段添加了一个称为checkType的标签，其中email的checkType标签的值是email,password的checkType的标签的值是password。
2. 之后，我将该结构体传送给一个叫 check 的函数， 这个函数只有一个参数，它的参数名是data,它的类型是Interface。check函数的功能就是对传入的参数进行校验，它会根据不同的checkType标签执行不同的校验函数。比如之前的loginDTO结构的email字段，它的checkType是email，那么check函数就会对这个字段使用邮箱校验进行校验。邮箱校验包括两步，一个就是判断邮箱格式是否正确，这里我采用了正则表达式。另外一个就是判断邮箱是否存在，这涉及到了数据库的访问。
3. 其他的登录表单处理过程也是这样的，比如注册表单对应的结构是registerDTO,它的每个字段也是有相应的checkType。


### 过渡层怎么设计？
1. 过渡层只是简单集成了数据库层所有对象的功能。校验层、控制层调用的都是这一层的方法，而不会调用数据库层的对象的方法。

### 数据库层怎么设计？
1. redis对象、图片上传器、验证码发送器只是简单封装了一些功能。
2. 比较复杂的是posgsql。我的数据库只有2个表，一个是用户个人信息表，这个表存放了用户的昵称、性别等信息，而另一个是用户账户表，这个表存放了用户的登录邮箱、登录密码等信息。以用户个人信息表为例，我把它的表项封装为了一个UserPersonalInformation结构，这个结构包括了表项的所有内容，如UserId表示用户Id,UserName表示用户名，UserSex表示用户性别。
3. 假如此时我想修改用户名，那我会创建一个UserPersonalInformation实例，将用户Id、用户名传入给这个实例，再将这个实例作为参数，传递给pgsql对象的Update方法，这个方法会调用getUpdateSql,生成对应的sql语句，之后pgsql就会执行这条语句，实现用户名的修改。



## 功能实现
### 邮件注册如何实现？
1. 当用户在前端输入了注册邮箱后，点击获取验证码按钮，之后服务器就会收到获取验证码的请求，进入 sendRegisterVrc 函数，该函数会向指定邮箱发送1个6位随机数字的验证码，并将该验证码与邮箱进行绑定，用于接下来的校验。
2. 用户查看邮件后，获得验证码，再将该验证码输入。点击注册按钮，之后服务器就会收到注册的请求，进入 Register 函数。 Register函数会获得请求的表单，再将表单传入校验层进行校验，其中就包括了邮箱格式校验、邮箱是否存在校验，以及验证码是否正确的校验。
3. 如果校验通过，那就删除之前验证码与邮箱的绑定关系，并生成新用户。否则只是提示验证码不正确。

### 登录如何实现？
1. 用户发送登录请求时，服务器会进入Login函数，这个函数首先会获得表单的数据，之后将表单数据传入校验层进行校验，这里的校验包括: 登录邮箱格式是否正确、是否存在以及密码格式是否正确...最后校验登录密码是否正确。
校验登录密码是否正确由以下几步组成。
	1. 先通过登录邮箱，找到数据库中该用户的密码，以及盐值。这个密码是加盐哈希后的密文。
	2. 将盐值拼接到登陆密码的最后，再用密钥对该加盐密码进行哈希，获得加盐哈希密码。
	3. 再将这个加盐哈希密码与数据库中的加盐哈希密码进行比对，如果相同，则表示密码正确，否则密码错误。
2. 当校验通过后，就修改用户的最近登录时间，设置token，并告知前端用户登录成功。

### 修改用户信息如何实现？
1. 用户点击修改个人信息后，服务器会收到这个请求，并进入修改用户个人信息的处理函数。
这个函数首先会获得表单的数据、以及token中的用户id。
2. 创建一个userPersonalInformation实例，将用户id，以及修改后的信息传入这个实例。再将这个结构传递给下层。
3. 最终postgresql对象会生成相应的sql语句并执行，实现用户信息的修改。


## 不足之处
1. 数据库层职责过多，它涉及到了邮件发送验证以及数据持久化。
2. 有一些命名令人迷糊，比如获取Token中userId的函数，我命名为了ParseToken，但更准确的应该是 GetUidFromToken，后者命名更为清晰。还有很多对象命名也不合理，比如一些以Manager为后缀的对象。
3. 校验层的check函数代码太多了，返回的参数也不好，它返回的是错误码、以及响应的错误信息，但其实返回一个错误码就可以了。
4. postgresql执行时没用事务，无法保证操作全部执行。比如 用户注册成功后，会创建2条表项，一条位于用户账户表，一条位于用户个人信息表，如果在执行过程中发生断电，那就会出现数据不一致的问题。
5. 定义了不必要的接口，比如mainDB接口，只有一个对象实现了它，那就是postgre对象。还有Cache接口，也是只有一个对象实现了它，那就是redis。
6. 设计模式生搬硬套。原先我采用了单例模式创建redis对象，它能连接redis数据库，但只是一条连接，这意味着如果这条连接挂掉，整个对象就都不能使用了。


## 满意的地方
1. 中间件层的代码比较优美。
2. 整体采用分层架构，底层函数代码修改的时候，上层函数不用进行修改。
3. 修改用户的信息比较方便，只需要将信息传入结构体，再将该结构体传入数据库层实现就可以了，而不需要再编写sql语句。

## 收获
1. 不要过早定义接口，不要生搬硬套设计模式。
2. 开始编写代码时要先进行初步设计，避免边编写边设计，从而导致某些对象、层级职责过多。
3. 代码编写是一个迭代的过程，编写过程肯定会遇到或多或少的问题。
4. 动手解决了sql注入的问题。比如生成update语句时，这条语句包括了 set A=B,  我最先生成update语句时，采用的是 字段名=值的这种模式，即比如用户想把用户名改为 helloWorld，那对应生成的update语句中一定包括   userName=helloWorld，这没有任何问题，但是当 用户名前缀为 -- 时，那这条语句后面的部分都被当做了注释，从而使得where子句消失，导致Update执行时，修改的不是该用户的用户名，而是所有用户的用户名。
	之后我将 setA=B中的B，替换为了$1, 执行改update语句时，将用户名作为一个整体，从而防止 -- 符号将该语句后部分注释掉，从而解决了sql注入的问题。
5. 编写代码不应只以功能实现为唯一目的，而更重要的是测试、以及提高代码可读性。